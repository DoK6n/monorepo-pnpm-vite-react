# 리액트에서 렌더링 최적화

## useMemo?

useMemo에서 Memo는 Memoization을 뜻하는데,  
동일한 값을 리턴하는 함수를 반복적으로 호출해야 한다면 맨 처음 호출됬을때의 값을 메모리에 저장해 필요할때마다 재사용하는 기법이다.  
간단히 말하자면 자주 필요한 값을 캐싱을 해두고 필요할때 다시 계산하지 않고 캐싱된 값을 꺼내서 쓰는것이다.

예)

```jsx
function calculate() {
  return 10;
}

function Component() {
  const value = calculate();
  return <div>{value}</div>;
}
```

리액트는 state와 props의 변화로 인해 리렌더링이 발생한다.  
컴포넌트가 렌더링이 될때마다 value는 초기화 되고 calculate함수는 반복적으로 호출되어 무의미한 계산을 반복해서 value에 반복적으로 할당하게 된다.

이때 useMemo를 사용하여 최적화를 진행할 수 있다.  
처음에 계산된 결과값을 메모리에 저장해서 컴포넌트가 반복적으로 렌더링이 되어도 메모리에 저장했던 결과값을 재사용한다.

### useMemo의 구조와 사용방법

```js
const value = useMemo(() => {
  return calculate();
}, [item]);
```

첫번째 인자값으로 콜백함수, 두번째 인자값으로 의존성 배열을 받는다.

1번째 인자값인 콜백함수는 메모이제이션 해줄 값을 계산해서 리턴해주는 함수이다.
이 콜백함수가 리턴하는 값이 useMemo가 리턴하는 값이다.

2번째 인자인 의존성 배열은 배열안의 요소의 값이 변경될때만 콜백함수를 호출해서 다시 메모이제이션된 값을 다시 메모이제이션 해준다. (빈배열은 맨 처음 컴포넌트가 마운트 되었을때만 메모이제이션 한다.)

> ! 주의 : useMemo는 값을 메모이제이션 하기위해 메모리를 소비하여 저장하기 때문에 불필요한 값까지 모두 적용한다면 오히려 성능이 악화될 수 있어서 적절하게 사용하는 것이 좋다.
